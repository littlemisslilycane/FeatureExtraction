# -*- coding: utf-8 -*-
"""PS1-Shakespeare.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/mutherr/CS6120-PS1/blob/master/PS1_Shakespeare.ipynb

In this experiment, you will train models to distringuish examples of two different genres of Shakespeare's plays: comedies and tragedies. (We'll ignore the histories, sonnets, etc.) Since he died four hundred years ago, Shakespeare has not written any more plays—although scraps of various other works have come to light. We are not, therefore, interested in building models simply to help categorize an unbounded stream of future documents, as we might be in other applications of text classification; rather, we are interested in what a classifier might have to tell us about what we mean by the terms “comedy” and “tragedy”.

You will start by copying and running your `createBasicFeatures` function from the experiment with movie reviews. Do the features the classifier focuses on tell you much about comedy and tragedy in general?

You will then implement another featurization function `createInterestingFeatures`, which will focus on only those features you think are informative for distinguishing between comedy and tragedy. Accuracy on leave-one-out cross-validation may go up, but it more important to look at the features given the highest weight by the classifier. Interpretability in machine learning, of course, may be harder to define than accuracy—although accuracy at some tasks such as summarization is hard enoough.
"""

import json
import requests
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_validate, LeaveOneOut
import string
import re
import nltk

nltk.download('wordnet')
from nltk.corpus import wordnet as wn


# read in the shakespeare corpus
def readShakespeare():
    raw = requests.get(
        "https://raw.githubusercontent.com/mutherr/CS6120-PS1-data/master/shakespeare_plays.json").text.strip()
    corpus = [json.loads(line) for line in raw.split("\n")]

    # remove histories from the data, as we're only working with tragedies and comedies
    corpus = [entry for entry in corpus if entry["genre"] != "history"]
    return corpus


"""This is where you will implement two functions to featurize the data:"""


# NB: The current contents are for testing only
# This function should return:
#  -a sparse numpy matrix of document features
#  -a list of the correct genre for each document
#  -a list of the vocabulary used by the features, such that the ith term of the
#    list is the word whose counts appear in the ith column of the matrix. 

# This function should create a feature representation using all tokens that
# contain an alphabetic character.
def createBasicFeatures(corpus):
    genres = []
    full_text = []

    for play in corpus:
        genres.append(play['genre'])
        full_text.append(play['text'])

    vectorizer = CountVectorizer()
    vectorizer.fit_transform(full_text)

    # Used regex to take words which have atleast one alphabet
    vocab = list(filter(lambda word: re.match(".*[a-zA-Z].*", word) is not None, vectorizer.get_feature_names()))

    # Used countvectorizer to set unigrams and the above vocabulary
    vectorizer = CountVectorizer(ngram_range=(1, 1), vocabulary=vocab)
    texts = vectorizer.fit_transform(full_text)

    return texts, genres, vocab


# This function can add other features you want that help classification
# accuracy, such as bigrams, word prefixes and suffixes, etc.
def createInterestingFeatures(corpus):
    # Your code here
    genres = []
    full_text = []
    for play in corpus:
        genres.append(play['genre'])
        full_text.append(play['text'])

    vocab = set()
    # I have used Nouns from the Wordnet library as the vocabulary for my features.
    # My initial thought process was to use adjectives but on further exploration
    # I noticed that with respect to shakespeare corpus, Nouns make more sense as the
    # corpus is sprinkled with Nouns which are clearly associated with a genre
    # For example, Jest, Death, tragedy, Destruction, romeo, juliet, etc.,
    # I tried to apply parts-of-speech tagging to identify Nouns from the corpus rather than external library
    # But POS tagging did not identify words properly as Nouns.
    # The results are considerably improved with 92% accuracy in L2 Norm.

    for synset in list(wn.all_synsets(wn.NOUN)):
        for item in synset.lemmas():
            if '_' not in item.name() and '-' not in item.name():
                vocab.add(item.name())
    vocab = list(vocab)

    # I used the presence representation than counts since the noun-genre mapping is clear enough
    # without the need for the count statistic
    vectorizer = CountVectorizer(vocabulary=vocab, binary='true')
    texts = vectorizer.fit_transform(full_text)
    vocab = vectorizer.get_feature_names()

    # The tragedy words are especially precise as seen in the results of L2 Norm
    return texts, genres, vocab


# given a numpy matrix representation of the features for the training set, the
# vector of true classes for each example, and the vocabulary as described 
# above, this computes the accuracy of the model using leave one out cross 
# validation and reports the most indicative features for each class
def evaluateModel(X, y, vocab, penalty="l1"):
    # X is the feature Y is the class and vocab is the list of features
    # create and fit the model
    model = LogisticRegression(penalty=penalty, solver="liblinear")
    results = cross_validate(model, X, y, cv=LeaveOneOut())

    # determine the average accuracy
    scores = results["test_score"]
    avg_score = sum(scores) / len(scores)

    # determine the most informative features
    # this requires us to fit the model to everything, because we need a
    # single model to draw coefficients from, rather than 26
    model.fit(X, y)
    neg_class_prob_sorted = model.coef_[0, :].argsort()
    pos_class_prob_sorted = (-model.coef_[0, :]).argsort()

    termsToTake = 20
    pos_indicators = [vocab[i] for i in neg_class_prob_sorted[:termsToTake]]
    neg_indicators = [vocab[i] for i in pos_class_prob_sorted[:termsToTake]]

    return avg_score, pos_indicators, neg_indicators


def runEvaluation(X, y, vocab):
    print("----------L1 Norm-----------")
    avg_score, pos_indicators, neg_indicators = evaluateModel(X, y, vocab, "l1")
    print("The model's average accuracy is %f" % avg_score)
    print("The most informative terms for pos are: %s" % pos_indicators)
    print("The most informative terms for neg are: %s" % neg_indicators)
    # this call will fit a model with L2 normalization
    print("----------L2 Norm-----------")
    avg_score, pos_indicators, neg_indicators = evaluateModel(X, y, vocab, "l2")
    print("The model's average accuracy is %f" % avg_score)
    print("The most informative terms for pos are: %s" % pos_indicators)
    print("The most informative terms for neg are: %s" % neg_indicators)


corpus = readShakespeare()

"""Run the following to train and evaluate two models with basic features:"""

X, y, vocab = createBasicFeatures(corpus)
runEvaluation(X, y, vocab)

"""Run the following to train and evaluate two models with features that are interesting for distinguishing comedy and tragedy:"""

X, y, vocab = createInterestingFeatures(corpus)
runEvaluation(X, y, vocab)
