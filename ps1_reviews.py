# -*- coding: utf-8 -*-
"""PS1-Reviews.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/littlemisslilycane/ed74069d6e025b032e8eeb6dfe9c5bb4/ps1-reviews.ipynb

In this experiment, you will explore the accuracy of sentiment classificaiton using different feature representations of text documents.

First, you will implement `createBasicFeatures`, which creates a sparse matrix representation of a collection of documents. For this exercise, you should have a feature for each word containing at least one alphabetic character. You may use the `numpy` and `sklearn` packages to help with implementing a sparse matrix.

Then, you will implement `createFancyFeatures`, which can specify at any other features you choose to help improve performance on the classification task.

The two code blocks at the end train and evaluate two models—logistic regression with L1 and L2 regularization—using your featurization functions. Besides held-out classification accuracy with 10-fold cross-validation, you will also see the features in each class given high weights by the model.
"""

import json
import re

import requests
from sklearn.linear_model import LogisticRegression
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import cross_validate, LeaveOneOut, KFold




# read in the movie review corpus
def readReviews():
    raw = requests.get(
        "https://raw.githubusercontent.com/mutherr/CS6120-PS1-data/master/cornell_reviews.json").text.strip()
    corpus = [json.loads(line) for line in raw.split("\n")]

    return corpus


"""This is where you will implement two functions to featurize the data."""


# NB: The current contents are for testing only
# This function should return:
#  -a sparse numpy matrix of document features
#  -a list of the correct class for each document
#  -a list of the vocabulary used by the features, such that the ith term of the
#    list is the word whose counts appear in the ith column of the matrix.

# This function should create a feature representation using all tokens that
# contain an alphabetic character.
def createBasicFeatures(corpus):
    classes = []
    full_text = []

    for document in corpus:
        classes.append(document['class'])
        full_text.append(document['text'])

    vectorizer = CountVectorizer()
    vectorizer.fit_transform(full_text)
    vocab = list(filter(lambda word: re.match(".*[a-zA-Z].*", word) is not None, vectorizer.get_feature_names()))
    vectorizer = CountVectorizer(ngram_range=(1, 1), vocabulary=vocab)
    texts = vectorizer.fit_transform(full_text)
    return texts, classes, vocab


# This function can add other features you want that help classification
# accuracy, such as bigrams, word prefixes and suffixes, etc.
def createFancyFeatures(corpus):
    classes = []
    full_text = []

    for document in corpus:
        classes.append(document['class'])
        full_text.append(document['text'])

    vectorizer = CountVectorizer()
    vectorizer.fit_transform(full_text)

    # Decided to use unigrams and bigrams for reviews since there are some
    # situation where terms like "not bad" makes it a positive review
    # Also chose presence representation since I noticed that the words in
    # the previous results were clear enough to be categorized as pos/neg
    vectorizer = CountVectorizer(ngram_range=(1, 2), binary='true')
    texts = vectorizer.fit_transform(full_text)
    vocab = vectorizer.get_feature_names()
    return texts, classes, vocab


# given a numpy matrix representation of the features for the training set, the
# vector of true classes for each example, and the vocabulary as described
# above, this computes the accuracy of the model using leave one out cross
# validation and reports the most indicative features for each class

def evaluateModel(X, y, vocab, penalty="l1"):
    # create and fit the model
    model = LogisticRegression(penalty=penalty, solver="liblinear")
    results = cross_validate(model, X, y, cv=KFold(n_splits=10, shuffle=True, random_state=1))

    # determine the average accuracy
    scores = results["test_score"]
    avg_score = sum(scores) / len(scores)

    # determine the most informative features
    # this requires us to fit the model to everything, because we need a
    # single model to draw coefficients from, rather than 26
    model.fit(X, y)
    class0_weight_sorted = model.coef_[0, :].argsort()
    class1_weight_sorted = (-model.coef_[0, :]).argsort()

    termsToTake = 20
    class0_indicators = [vocab[i] for i in class0_weight_sorted[:termsToTake]]
    class1_indicators = [vocab[i] for i in class1_weight_sorted[:termsToTake]]

    if model.classes_[0] == "pos":
        return avg_score, class0_indicators, class1_indicators
    else:
        return avg_score, class1_indicators, class0_indicators


def runEvaluation(X, y, vocab):
    print("----------L1 Norm-----------")
    avg_score, pos_indicators, neg_indicators = evaluateModel(X, y, vocab, "l1")
    print("The model's average accuracy is %f" % avg_score)
    print("The most informative terms for pos are: %s" % pos_indicators)
    print("The most informative terms for neg are: %s" % neg_indicators)
    # this call will fit a model with L2 normalization
    print("----------L2 Norm-----------")
    avg_score, pos_indicators, neg_indicators = evaluateModel(X, y, vocab, "l2")
    print("The model's average accuracy is %f" % avg_score)
    print("The most informative terms for pos are: %s" % pos_indicators)
    print("The most informative terms for neg are: %s" % neg_indicators)


corpus = readReviews()

"""Run the following to train and evaluate two models using basic features:"""

X, y, vocab = createBasicFeatures(corpus)
runEvaluation(X, y, vocab)

"""Run the following to train and evaluate two models using extended features:"""

X, y, vocab = createFancyFeatures(corpus)
runEvaluation(X, y, vocab)
